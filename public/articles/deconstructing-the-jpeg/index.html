<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, minimum-scale=1.0"
    />
    <title>Unraveling The JPEG</title>
    <meta property="og:title" content="Unraveling The JPEG" />
    <meta charset="utf-8" />
    <meta property="og:type" content="article" />

    <meta property="og:description" content="Short description of your project" />
    <meta property="description" content="Short description of your project" />

    <link rel="stylesheet" href="static/idyll_styles.css" />
  </head>
  <body>
    <div id="idyll-mount"><div data-reactroot=""><div class="idyll-root"><div class=" idyll-text-container"></div><div style="margin-top:25px;margin-left:50px;margin-right:50px;z-index:1000"><div><img src="static/images/logo.png" style="display:inline;width:238px"/></div><div style="display:flex;width:100%;justify-content:space-between;font-size:32px;font-family:Graphik Web;text-decoration:underline;margin-top:0.5em;line-height:32px"><div>Issue 01<br/>Science + Society</div><div style="cursor:pointer;z-index:1000">Table of Contents</div></div><div style="display:none;position:fixed;width:500px;right:0;top:0;bottom:0;padding:2em;padding-top:8em;background:#FFE533;overflow:auto;z-index:999"><div style="text-align:right;font-size:32px"><div style="margin-bottom:2em;display:flex;flex-direction:row;justify-content:flex-end"><div><div style="font-family:Graphik Web">Decoding the JPEG</div><div style="font-style:italic;font-weight:300;font-family:Graphik Web">By Omar Shehata</div></div><div style="margin-left:1em;font-family:Graphik Web">01</div></div></div><div style="text-align:right;font-size:32px"><div style="margin-bottom:2em;display:flex;flex-direction:row;justify-content:flex-end"><div><div style="font-family:Graphik Web">Decoding the JPEG</div><div style="font-style:italic;font-weight:300;font-family:Graphik Web">By Omar Shehata</div></div><div style="margin-left:1em;font-family:Graphik Web">02</div></div></div><div style="text-align:right;font-size:32px"><div style="margin-bottom:2em;display:flex;flex-direction:row;justify-content:flex-end"><div><div style="font-family:Graphik Web">Decoding the JPEG</div><div style="font-style:italic;font-weight:300;font-family:Graphik Web">By Omar Shehata</div></div><div style="margin-left:1em;font-family:Graphik Web">03</div></div></div><div style="text-align:right;font-size:32px"><div style="margin-bottom:2em;display:flex;flex-direction:row;justify-content:flex-end"><div><div style="font-family:Graphik Web">Decoding the JPEG</div><div style="font-style:italic;font-weight:300;font-family:Graphik Web">By Omar Shehata</div></div><div style="margin-left:1em;font-family:Graphik Web">04</div></div></div><div style="text-align:right;font-size:32px"><div style="margin-bottom:2em;display:flex;flex-direction:row;justify-content:flex-end"><div><div style="font-family:Graphik Web">Decoding the JPEG</div><div style="font-style:italic;font-weight:300;font-family:Graphik Web">By Omar Shehata</div></div><div style="margin-left:1em;font-family:Graphik Web">05</div></div></div><div style="text-align:right;font-size:32px"><div style="margin-bottom:2em;display:flex;flex-direction:row;justify-content:flex-end"><div><div style="font-family:Graphik Web">Decoding the JPEG</div><div style="font-style:italic;font-weight:300;font-family:Graphik Web">By Omar Shehata</div></div><div style="margin-left:1em;font-family:Graphik Web">06</div></div></div></div></div><div class="article-header" style="margin-top:0"><div style="display:flex;width:100vw;position:relative;top:4em"><div style="position:relative;height:520px;z-index:2"><div title="Unraveling,The JPEG" date="April 15, 2019" dek="&lt;Some text goes here about the details of the article. This should be short and engaging to draw people in.&gt;" authors="[object Object]" doi="" archive="" source="" class=" idyll-text-container"><div style="position:relative;width:720px"><div style="position:absolute;width:100%;left:-5em"><h1 class="hed"><span>Unraveling</span><br/><span>The JPEG</span></h1><h1 class="hed hed-offset"><span>Unraveling</span><br/><span>The JPEG</span></h1></div><div style="width:720px;max-width:720px;position:relative;top:120px;font-size:12px;line-height:20px;color:#4801FF;font-family:Silkscreen"><div><div style="font-weight:900;font-family:Graphik Web;font-size:48px;line-height:64px"><span>Unraveling</span><br/><span>The JPEG</span></div><div>April 15, 2019</div></div><div style="display:flex;flex-direction:row"><div><div style="font-weight:bold">Created By</div><div><div><a>Omar Shehata</a> </div></div></div><div style="margin-left:4em"><div style="font-weight:bold">Metadata</div><div><a>Source Code</a><br/><a>Offline Archive</a><br/></div></div></div></div></div></div></div><div class="parametric-header-image" style="position:relative;top:150px"><img src="static/images/jpeg.png"/></div><h1 class="hed-rotate"><span>Unraveling</span><br/><span>The JPEG</span></h1></div><div title="Unraveling,The JPEG" date="April 15, 2019" dek="&lt;Some text goes here about the details of the article. This should be short and engaging to draw people in.&gt;" authors="[object Object]" doi="" archive="" source="" class=" idyll-text-container"><div style="font-family:Graphik Web;font-size:32px;line:48px">&lt;Some text goes here about the details of the article. This should be short and engaging to draw people in.&gt;</div></div></div><div class=" idyll-text-container"><p>If you’ve ever used the internet, you’ve probably seen a JPEG image. JPEG is a standard for image compression that’s brought us a world where colorful, high quality images can easily be shared. From web pages, to email, to social media and smartphones, it’s used billions of times per day across all of our devices every time we view or send images online. Without JPEG, the web would be a little less colorful, a lot slower, and possibly host a lot less cat pictures.</p><p>Despite its ubiquity in our lives, JPEG is often treated as a black box. You might be aware that it’s a <strong>lossy</strong> compression technique; it throws away data that we’re not likely to notice to reduce file size, but what does that data look like? How does it decide what we will or won’t notice? And is that assumption correct all the time? (Spoiler: it’s not!)</p><p>There’s even more mysteries that arise when we look at how JPEG images are stored. If you open a JPEG image in a text editor, you’ll see the raw bytes; the list of numbers that represent this image on your computer. Below is an image and its raw bytes.</p><p>Try changing the first 17 to a 1 or 16. Or try changing the first 232 to 252.</p></div><div style="width:100%"></div><div class=" idyll-text-container"><p><span class="replace-link">Changing this single number</span> somehow alters the entire image, and quite spectacularly so! It’s not too surprising that changing these numbers will change the colors in the image, but certain numbers seem to change, not the color...but the shape? To see what I mean, try changing the second 69 to 251 or greater and look at the top left corner of the image. These checkboard patterns are always hiding in there, no matter what JPEG image you use.</p><p>This article will explore how JPEG works by reverse engineering it. You’ll get to unravel each of these mysteries by making changes like this, observing what they do to the image, and gathering clues!</p><p>I think learning about JPEG is valuable not just because it’s important to understand the technology we all use everyday, but also because as we peel off each layer of compression we’ll learn about visual perception – what details matter most to our eyes, as well as information theory, and a little bit of linear algebra.</p></div><div style="width:100%"></div><div class=" idyll-text-container"><h2>Why does one number change the entire image?</h2><p>Let’s look at this effect in a simpler image. Here’s a 16x8 image that’s just a black square and a white square. See if you can find the number that changes the whole image without corrupting it.</p><textarea rows="4" cols="50"></textarea><div style="width:100%"></div><p>The first number that has this property is 252. Changing it to 251 changes the black to white and the white to grey. Other values bring out the checkboard patterns.</p><p>To figure out why this is happening, a good general technique when reverse engineering is to try and re-invent the thing you’re trying to understand. This is akin to solving a crime by putting yourself in the shoes of the suspect. If you think about where <em>you</em> would have hidden the weapon it might help you find it.</p><p>In this case, we know the goal of JPEG is to make the file size smaller – to use less bytes when representing the image. Here’s what the black and white image would look like if we represented it as just a list of the color of every pixel.</p><p><br/><br/><em>Figure of the same as above, except it’s about <!-- -->1<!-- -->6<!-- -->*<!-- -->8<!-- -->*<!-- -->3<!-- --> = <!-- -->3<!-- -->8<!-- -->4<!-- --> numbers.</em> <br/><br/></p><p>That’s a lot more numbers. This is storing the color in 3 numbers (red, green, blue), for every pixel (it’s a 16x8 image, so there’s 16*8 = 128 pixels). But we don’t <em>really</em> need all that much to describe this simple image. Can you think of a way to represent this image with fewer bytes? For example, one easy way is to use 1 number for the color of each pixel instead of 3 since this image is just black and white.</p><p>The smallest reasonable representation I could think of is 8 numbers: store the color (3 numbers) followed by how many pixels have this color. That’ll allow us to store each block of solid color in exactly 4 numbers.</p><p><br/><br/><em>Figure of those <!-- -->4<!-- --> numbers with the resulting image.</em> <br/><br/></p><p>We just made up our own format, and it’s actually better than JPEG (in this one particular case)! If this were a real image, it would probably be <em>worse</em> than just naively storing all the colors. Do you see why?</p><p>The reason I said this is the “smallest reasonable representation” is because we could technically store any image, no matter how big, in a single number, by simply declaring that the number 0 represents that particular image. When I say “Mona Lisa”, I’ve just communicated an entire image using just 2 words, but obviously, this won’t work if I want to communicate images you’ve never seen before.</p><p>Representing large areas that have the same color with 2 numbers instead of storing the color of every single pixel saves a huge amount of bytes. This is known as <strong>Run-length encoding (RLE)</strong> and is used in any situation when you have a lot of repeated values next to each other, not just on images. For example, audio files typically have long moments of silence at the beginning or the end, which would benefit from this way of representing them.</p><p>You can actually go back and confirm that this is indeed what’s happening. Try scrolling down and changing values closer to the bottom. Notice how as you go down in the list of numbers, changing a value only affects subsequent values!</p><textarea rows="12" cols="70"></textarea><div style="width:100%"></div><h2>Why do some changes corrupt the image?</h2><p>RLE explains why numbers change subsequent colors, but why do some innocuous changes just outright “corrupt” the image? If you haven’t seen this already try changing the very first number in any of the figures above. If you tried to open that edited JPEG image, it might say something like:</p><img src="static/images/unsupported_windows.png"/><em>This is what it says in the Windows photo app.</em><br/><br/><p>If these numbers represent colors, we wouldn’t expect this to happen unless we did something like set a color to a negative value or something like that. But as we saw earlier, changing a 17 to 15 suddenly made the browser no longer capable of recognizing it as an image.</p><p>This is admittedly the hardest part to reverse engineer without looking up the JPEG standard. As promised, before I explain it I’ll give you a chance to uncover it yourself. The best hint I can give you is that we need to look at the header. Most articles on editing JPEGs will tell you not to touch it since it mostly contains metadata, like how big the image is, how many bytes to expect, etc. so changing those numbers easily makes the image unreadable.</p><p>For example, the first two bytes in the body are the “Start of Image” marker. This is what marks a list of numbers a JPEG image, as opposed to a PNG, or a Word document (contrary to what operating systems might have you believe, the file extension really doesn’t matter that much). This is the marker that the browser/photo viewers look for when deciding how to decode these numbers, so if it’s not there, it won’t know to read it as a JPEG. This is one way of corrupting an image.</p><p>However, there is a string of special values in the header that we can always safely change, that will always have the most dramatic effect on the image. Look for a “255, 196” pair (you can just CTRL+F this), then skip 19 bytes. The first number after will always have the most dramatic effect on the image, with subsequent numbers having less and less of an effect.</p><p>There can be up to four (and at least one) “255, 196” pairs that have different effects.</p><p>
Body:<br/><textarea rows="12" cols="70"></textarea><br/>
Header:<br/><textarea rows="6" cols="70"></textarea><div style="width:100%"></div><em>In the real thing, this might be nice to have as switching tabs, from header to body, in the same way CodePen lets you have HTML<!-- -->/CSS tabs.</em><br/></p><p>Without these four “255, 196” pairs, and the numbers that follow, it would be practically impossible to decode the JPEG. It would be as if I just made up a new language that was particularly efficient at describing one particular painting. It might be a beautifully concise description, but it wouldn’t make sense to anyone else.</p><p>This might sound ridiculous, but these numbers are indeed a dictionary for a made up language-of-sorts unique to this particular image!</p><h3>Variable Length encoding</h3><p>The “255, 196” byte pair marks the definition of a Huffman encoding table. It tells us how to read the bytes in the JPEG.</p><p>Why would you want to create a unique dictionary for each image like this? Imagine if you had an image, after doing all your compression, the numbers looked like this:</p><pre><code>1 1 1 255 1 1</code></pre><p>These are 6 decimal numbers. In binary, these are stored as:</p><pre><code>00000001 00000001 00000001 11111111 00000001 00000001</code></pre><p>That’s a total of 48 bits. We use 8 bits per number so that we can store numbers up to 255, but that means we’re wasting 7 bits on almost all of our numbers here. Ideally, you’d store every number in as many bits it needs and no more. So it would be:</p><pre><code>1   1   1   11111111    1   1</code></pre><p>This is now only 13 bits. We’ve just made our data over (13/48) 3x as small! That’s like taking a 10 MB image, too big for a web page, and squeezing it into 3 MB, just by removing unnecessary bits, no change to the image quality whatsoever.</p><p>There’s one problem though - I deliberately spaced out the numbers when showing it so you’d know where each one starts and ends. But when you’re reading bits in a file, this is what you’d get:</p><pre><code>1111111111111</code></pre><p>These are the 13 bits. Is the first number a 1? Or is it a 11 (a 3 in decimal)? Or is it a 11111111? We need a way to somehow know how many bits to read for each number.</p><p>This is a fun problem to try and solve with many creative solutions. For example, you could say you’ll put a stop marker in there, maybe it’s “0”. But then you have to figure out a way to represent “0″! I won’t spoil it, but Huffman encoding is the answer. It is the most efficient way of packing a string of bits without using start/stop markers. There are many good explanations on it, <a href="TODO:link to ComputerPhile video?">here’s</a> one of my favorite.</p><p>As long as we understand that to make sense out of these numbers, we must first translate them based on the Huffman tables, we can keep going. As an example, for the simple image, here’s what the first Huffman table looks like:</p><br/><br/><em>Embed Huffman table. This would be cool if done dynamically, so you could drag and drop an image and see its table.</em><br/><br/><p>So while the first two numbers look like “X, Y”, to uncover what they really are, we unpack them into their binary bits:</p><pre><code>binary bits here</code></pre><p>And notice that the first sequence is “W” from the table. (We then have to take this and further decode it from another Huffman table, this one not found in the file anywhere, but in the JPEG spec. But this detail isn’t that important right now?)</p><p>Doing this for the whole image, we get the following representation:</p><p><br/><br/><em>Figure of image, same as previous, textbox and image, except now it’s all the DCT coefficients</em>.<br/><br/></p><p>(Interested readers can see exactly how to perform this step in the source code.)</p><p>You might have hoped what we’d have now is finally raw color values, but a few seconds of playing around with the numbers above shows this is not the case. Notice that none of the steps we’ve uncovered so far could have had any data lost or thrown away, they were all <strong>lossless</strong> compression steps. The defining feature of JPEG is its lossy nature, so there’s bound to be more to the story.</p><h2>Where do the mysterious checkboard patterns come from?</h2><p>Despite removing all but the final compression layer, what we have now is still far from a list of colors. We no longer get single numbers that change the whole image, since we’ve removed RLE. Changing numbers should have more predictable results now, since these numbers correspond directly to <em>something</em>, even if it’s not color (as opposed to before, we couldn’t tell where one number started and the other ended because of the variable length encoding).</p><p>What is more pronounced though is the checkboard patterns. It’s even more obvious in our simple image:</p><p><br/><br/><em>interactive DCTs of simple image</em>.<br/><br/></p><p>This is my favorite part to reverse engineer. There’s a very clear systematic pattern here. Higher numbers are denser patterns, with 0 and 1 being all white and all black respectively. Do you have any guesses on what’s going on here?</p><p>It takes a bit of leap to see how this works, so I’ll give you one good hint. Here is one more JPEG images stripped down to what I’ll call its “checkboard numbers”.</p><br/><br/><em>interactive DCTs of another simple image chosen such that it has many components, to give you the hint that these patterns are added together to make the image.</em><br/><br/><p>Try changing the numbers starting at X, setting them at 0, one by one. Can you see how these patterns represent the image?</p><h3>Breaking down images</h3><p>What we’re looking at here is the <strong>Discrete Cosine Transforms</strong> coefficients. These checkboard patterns are generated by cosine functions, which are them combined together to form the final image. The numbers we’ve got here, the coefficients, control how much of each pattern is represented. There are 64 total patterns.</p><p>Here is a popular GIF from Wikipedia that’s often used to show how these are added together to get an image:</p><img src="static/images/wiki_dct.gif"/><p>We can actually do this ourselves now. Below is that “A” image, and you can selectively remove the patterns that make it up.</p><br/><br/><em>If it’s too hard to do this in the raw numbers, we might just have a nicer format<!-- -->/sliders here. The point is that this will be the first viz I’ve ever seen that lets me really understand this popular animation.</em><br/><br/><p>You’ll hear them called “waves”, because this checkboard pattern is really a 3D plot, where the color represents the “height”.</p><br/><br/><em>Side by side of the checkboard pattern, next to its <!-- -->3<!-- -->D plot, and the equation generating it, which you can change, so you really understand why it’s a ‘wave’.</em><br/><br/><p>This seems a bit like magic. These cosine waves are not generated for each image. Every possible image that has ever existed, or will ever existed, is a combination of these, specific, 64 patterns. This is known as a basis in Linear Algebra.</p><h3>Why represent images this way?</h3><p>It’s pretty cool to know you can represent an image as a <em>sum of cosine waves</em> instead of a list of color values, but you should be asking yourself why anyone want to represent things in this esoteric way. Remember that our goal is to reduce the number of bytes needed to represent images, and it takes just as many bytes to represent images as a sum of waves as it does to represent them as a list of colors.</p><p>We’re not strict about keeping the image in its original form. If we can throw away some detail to make the image significantly smaller, that’s great. The problem with our list-of-colors representation is that throwing away bytes just causes us to lose those pixels, we don’t get a lower quality version of the same image.</p><p>So while it takes the same amount of information to store the image in both ways, the DCT way makes it easier to <em>find things to throw away that won’t change the image too much</em>.</p><p>This is exactly the same reason JPEG uses YCbCr instead of RGB. To represent the color of any given pixel, it takes the 3 numbers, whether you’re using RGB or YCbCr, but if you were forced to throw away 2 of those numbers, the image with just Y would look much better than the image with R, G, or B (or Cb or Cr).</p><h3>Tossing away information</h3><p>Let’s see what this looks like! Let’s do some vision experiments. Here is an image with all of its DCT coefficients. Try removing each to see how many you can get to 0 and still get a recognizable image.</p><p><br/><br/>_._<br/><br/></p><p>What you just did here is what JPEG does, to every 64x64 pixel block in the image!</p><p>&lt;Point out that this way of representing data doesn’t just apply to images. It works on anything! This is used in audio to remove noise for example&gt;</p><h2>Chroma Sub-sampling</h2><p>We could stop here, but we’ll be leaving one of the biggest mysteries on the table! Why YCbCr as opposed to RGB? It’s because we can downsample color, separately from the image.</p><p>This is a peculiar idea because, what <em>is</em> the image if not a collection of color? Just like there are many ways to represent numbers, we can represent colors in different ways too. With RGB, you add these colors together. With YCbCr, you have the luminance, and then two color components.</p><br/><br/><em>Show a <!-- -->7<!-- --> figure diagram. <!-- -->1<!-- --> image, and then <!-- -->3<!-- --> images for its RGB components separately. Then the <!-- -->3<!-- --> images for its YCbCr components separately.</em><br/><br/><p>We just so happen to be more sensitive to luminance. Possibly because of the way our vision evolved. Anyone will tell you that JPEG downsamples only the color because otherwise image would look bad, but I was very curious, what happens if we downsample luminance instead?</p><br/><br/><em>Dynamic figure of an image with sliders. I want to be able to see what happens when I downsample any individual component. And do this for RGB as well, since no JPEG editing program lets you do this.</em><br/><br/><h2>Discrete cosine transform for the whole image (optional<!-- -->/addendum)</h2><p>JPEG only applies the DCT to the image in 64x64 blocks. This is why most animations of it you’ll see are on tiny images.</p><p>There’s absolutely nothing stopping us from doing this to the whole image! JPEG does it this way both for computationally efficiency and because at high compression rates, the whole image averaged out looks like a blob. But 64x64 blocks averaged out still looks recognizable.</p><p>But DCT is supposed to let you represent <em>any</em> image, using these coefficients, so what does this look like? I wanted to see it. Here’s a sandbox for you to try this out, on any image you like!</p><br/><br/><em>Interactive DCT for the whole image. If it can’t be done in real time, post pictures of it here and link to the GitHub wit instructions on how to do it.</em><br/><br/></div></div></div></div>
    <script src="static/js/jpeg.js"></script>
    <script src="static/idyll_index.js"></script>
  </body>
</html>
